from enum import Enum
from abc import *


class Color(Enum):
    White = 1
    Black = 2


class Piece(ABC):
    def __init__(self, Color):
        image_path = #however you do the image path
        _game = # doesn't say
        self.color = Color
        self._image = pygame.Surface((105, 105), pg.SRCALPHA)
        self.board = [[None for _ in range(9)] for _ in range(9)]

    def set_game(game):
        if not isinstance(game, Game):
            raise ValueError("You must provide a Valid Game instance.")
        Piece._game = Game

    @property
    def color(self) -> Color:
        return self._color

    def set_image(self, x: int, y: int) -> None:
        self._image.blit(Piece.SPRITESHEET, (0, 0), pygame.rect.Rect(x, y,
        105, 105))

    def _diagonal_moves(self, y: int, x: int, y_d: int, x_d: int, distance:int) -> List[Tuple[int, int]]:
        moves = []
        for i in range(1, distance):
            row = y + (i * y_d + 1)
            col = x + (i * x_d +1)

            if not self.valid_moves(row, col):
                break
            possible_piece = self.board[row][col]

            if possible_piece is None:
                moves.append((row, col))

            elif possible_piece != self.color:
                moves.append((row, col))
                break

            else:
                break
        return moves

    def _horizontal_moves(self, y, x, y_d, x_d, distance):
        moves = []
        for i in range(1, distance):
            left = x - (i * x_d + 1)
            right = x + (i * x_d + 1)

            if not self.valid_moves(left, right)
                break

            possible_piece = self.board[left][right]
            if possible_piece is None:
                moves.append((left, right))
                break

            elif possible_piece != self.color:
                moves.append((left, right))
                break

            else:
                break
        return moves


    def _vertical_moves(self, y, x, y_d, x_d, distance):
        moves = []
        for i range(1, distance):
            up = y + (i * y_d + 1) # counts 0 as 1 so + 1 here
            down = y - (i * y_d + 1)

            if not self.valid_moves(up, down)
                break

            possible_piece = self.board[up][down]
            if possible_piece is None:
                moves.append((up, down))
                break

            elif possible_piece != self.color:
                moves.append((up, down))
                break

            else:
                break
        return moves

    def get_diagonal_moves(self, y, x, distance, moves):
        moves += self._diagonal_moves(y, x, distance, 1, 1)
        moves += self._diagonal_moves(y, x, distance, -1, 1)
        moves += self._diagonal_moves(y, x, distance, 1, -1)
        moves += self._diagonal_moves(y, x, distance, -1, -1)
        return moves

    def get_horizontal_moves(self, y, x, distance):
        moves = self._horizontal_moves(y, x, distance, 1)
        moves += self._horizontal_moves(y, x, distance, -1)
        return moves

    def get_vertical_moves(self, y, x, distance, moves):
        moves = self._vertical_moves(y, x, distance, 1)
        moves += self._vertical_moves(y, x, distance, -1)
        return moves

    @abstractmethod
    def valid_moves(self, y, x):
        pass

    @abstractmethod
    def copy(self):
        pass


class King(Piece):
    def __init__(self, Color):
        self.color = Color
