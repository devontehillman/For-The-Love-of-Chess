from enum import Enum
from abc import *
import copy
from game import *


class Color(Enum):
    White = 1
    Black = 2


class Piece(ABC):
    _game =  Game
    def __init__(self, Color):
        image_path = #however you do the image path
        self.color = Color
        self._image = pygame.Surface((105, 105), pg.SRCALPHA)

    def set_game(game):
        if not isinstance(game, Game):
            raise ValueError("You must provide a Valid Game instance.")
        Piece._game = game

    @property
    def color(self) -> Color:
        return self._color

    def set_image(self, x: int, y: int) -> None:
        self._image.blit(Piece.SPRITESHEET, (0, 0), pygame.rect.Rect(x, y,
        105, 105))

    def _diagonal_moves(self, y: int, x: int, y_d: int, x_d: int, distance:int) -> list[Tuple[int, int]]:
        moves = []
        for i in range(1, distance):
            row = y + (i * y_d + 1)
            col = x + (i * x_d +1)

            if not self.valid_moves(row, col):
                break

            possible_piece = self._game.board[row][col]

            if possible_piece is None:
                moves.append((row, col))

            elif possible_piece != self.color:
                moves.append((row, col))
                break

            else:
                break
        return moves

    def _horizontal_moves(self, y, x, y_d, x_d, distance):
        moves = []
        for i in range(1, distance):
            left = x - (i * x_d + 1)
            right = x + (i * x_d + 1)

            if not self.valid_moves(left, right)
                break

            possible_piece = self._game.board[left][right]

            if possible_piece is None:
                moves.append((left, right))
                break

            elif possible_piece != self.color:
                moves.append((left, right))
                break

            else:
                break
        return moves


    def _vertical_moves(self, y, x, y_d, x_d, distance):
        moves = []
        for i range(1, distance):
            up = y + (i * y_d + 1) # counts 0 as 1 so + 1 here
            down = y - (i * y_d + 1)

            if not self.valid_moves(up, down)
                break

            possible_piece = self._game.board[up][down]

            if possible_piece is None:
                moves.append((up, down))
                break

            elif possible_piece != self.color:
                moves.append((up, down))
                break

            else:
                break
        return moves


    def get_diagonal_moves(self, y, x, distance, moves):
        moves += self._diagonal_moves(y, x, 1, 1, distance)
        moves += self._diagonal_moves(y, x, -1, 1, distance)
        moves += self._diagonal_moves(y, x, 1, -1, distance)
        moves += self._diagonal_moves(y, x, -1, -1, distance)
        return moves

    def get_horizontal_moves(self, y, x, distance):
        moves = self._horizontal_moves(y, x, 0, 1, distance)
        moves += self._horizontal_moves(y, x, 0, -1, distance)
        return moves

    def get_vertical_moves(self, y, x, distance):
        moves = self._vertical_moves(y, x, 1, 0, distance)
        moves += self._vertical_moves(y, x, -1, 0, distance)
        return moves


    @abstractmethod
    def valid_moves(self, y, x):
        pass

    @abstractmethod
    def copy(self):
        pass


class King(Piece):
    def __init__(self, Color):
        super().__init__(Color)
        self.color = Color

        if self.color == White:
            self.set_image()

        if self.color == Black:
            self.set_image()


    def valid_moves(self, y, x):
        moves = []
        moves += super().get_horizontal_moves(y, x, 1)
        moves += super().get_vertical_moves(y, x, 1)
        moves += super().get_diagonal_moves(y, x, 1, [])

        return moves


    def copy(self):
        return copy.deepcopy(self)  # is this how to deepcopy? this seems lazy and wrong

class Queen(Piece):
    def __init__(self, Color):
        super().__init__(Color)
        self.color = Color

        if self.color == White:
            self.set_image()

        if self.color == Black:
            self.set_image()


    def valid_moves(self, y, x):
        moves = []
        moves += super().get_horizontal_moves(y, x, 8)
        moves += super().get_vertical_moves(y, x, 8)
        moves += super().get_diagonal_moves(y, x, 8, [])

        return moves


    def copy(self):
        return copy.deepcopy(self)  # is this how to deepcopy? this seems lazy and wrong


class Bishop(Piece):
    def __init__(self, Color):
        super().__init__(Color)
        self.color = Color

        if self.color == White:
            self.set_image()

        if self.color == Black:
            self.set_image()


    def valid_moves(self, y, x):
        moves = []
        moves += super().get_diagonal_moves(y, x, 8, [])
        return moves


    def copy(self):
        return copy.deepcopy(self)  # is this how to deepcopy? this seems lazy and wrong


class Knight(Piece):
    def __init__(self, Color):
        super().__init__(Color)
        self.color = Color

        if self.color == White:
            self.set_image()

        if self.color == Black:
            self.set_image()



    def valid_moves(self, y, x):
        moves = []
        possible_moves = [(y+2, x+1), (y+2, x-1), (y+1, x+2), (y+1, x-2),
                          (y-2, x+1), (y-2, x-1), (y-1, x+2), (y-1, x-2)]
        for move in possible_moves:
            if 0 <= move[0] <= 8 and 0 <= move[1] <= 8:
                if self._game.board[move[0]][move[1]] != self.color:
                    moves.append(move)

        return moves


    def copy(self):
        return copy.deepcopy(self)  # is this how to deepcopy? this seems lazy and wrong


class Rook(Piece):
    def __init__(self, Color):
        super().__init__(Color)
        self.color = Color

        if self.color == White:
            self.set_image()

        if self.color == Black:
            self.set_image()


    def valid_moves(self, y, x):
        moves = []
        moves += super().get_horizontal_moves(y, x, 8)
        moves += super().get_vertical_moves(y, x, 8)
        return moves


    def copy(self):
        return copy.deepcopy(self)  # is this how to deepcopy? this seems lazy


class Pawn(Piece):
    def __init__(self, Color):
        super().__init__(Color)
        self.color = Color
        self.first_move = False

    if self.color == White:
        self.set_image()

    if self.color == Black:
        self.set_image()


    def valid_moves(self, y, x):
        moves = []
        if not self.first_move:
            moves += super().get_vertical_moves(y, x, 2)
            self.first_move = True

        if self.first_move:
            moves += super().get_vertical_moves(y, x, 1)

        possible_piece_right = self._game.board[y+1][x+1]
        if possible_piece_right != self.color and possible_piece_right is not None:
            moves += possible_piece_right

        possible_piece_left = self._game.board[y+1][x-1]
        if possible_piece_left != self.color and possible_piece_left is not None:
            moves += possible_piece_left

        return moves
    
    def copy(self):
        return copy.deepcopy(self)
